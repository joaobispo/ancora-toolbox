/*
 *  Copyright 2010 Ancora Research Group.
 * 
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 * 
 *       http://www.apache.org/licenses/LICENSE-2.0
 * 
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  under the License.
 */

package org.ancora.SharedLibrary.AppBase.Extra;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.ancora.SharedLibrary.AppBase.AppOption;
import org.ancora.SharedLibrary.AppBase.AppOptionType;
import org.ancora.SharedLibrary.EnumUtils;
import org.ancora.SharedLibrary.Files.LineReader;
import org.ancora.SharedLibrary.LoggingUtils;
import org.ancora.SharedLibrary.Parsing.ParsingConstants;

/**
 * Given a file generated by AppUtils.generateFile, parses it and returns a table
 * which maps the name of the options to the corresponding AppOption.
 *
 * @author Joao Bispo
 */
public class AppOptionParser {

   /**
    * Parses a file created by AppUtils.generateFile into a String-AppOption map.
    *
    * @param file
    * @return
    */
   public Map<String, AppOption> parse(File file) {
      // Reset state
      reset();

      // Create LineReader
      LineReader lineReader = LineReader.createLineReader(file);
      if(lineReader == null) {
         LoggingUtils.getLogger().
                 warning("LineReader is null.");
         return null;
      }

      // Extract name of the enum class
      String line = lineReader.nextNonEmptyLine();
      line = line.trim();
      if(!line.startsWith(AppUtils.CLASS_PREFIX)) {
         LoggingUtils.getLogger().
                 warning("Expected first written line to start with '"+AppUtils.CLASS_PREFIX+
                 "'. Found instead on line "+lineReader.getLastLineIndex()+": '"+line+"'");
         return null;
      }

      // Get enum table
      int startIndex = AppUtils.CLASS_PREFIX.length();
      String className = line.substring(startIndex).trim();
      Class<?> enumClass = null;
      try {
         enumClass = Class.forName(className);
      } catch (ClassNotFoundException ex) {
         LoggingUtils.getLogger().
                 warning("Could not find class '"+className+"'.");
         return null;
      }

      if(!enumClass.isEnum()) {
          LoggingUtils.getLogger().
                 warning("Class '"+className+"' does not represent an enum.");
         return null;
      }

      Map<String, AppOptionEnum> enumMap = AppUtils.buildMap((AppOptionEnum[]) enumClass.getEnumConstants());

      // Build map
      Map<String, AppOption> map = buildMap(lineReader, enumMap);

      
/*

      String line = null;
      while((line = lineReader.nextLine()) != null) {
         // Parse line
         AppOption appOption = parseAppOptionLine(line);

      }
*/
      return map;
   }

   /**
    * Cleans this object state.
    */
   private void reset() {
      lists = new HashMap<String, List<String>>();
      //lists = new HashMap<AppOptionEnum, List<String>>();
      
   }

   /**
    * Reads LineReader, parses the lines and builds the table which maps
    * option names to AppOption objects.
    *
    * @param lineReader
    * @param enumMap
    * @return
    */
  private Map<String, AppOption> buildMap(LineReader lineReader, Map<String, AppOptionEnum> enumMap) {
      Map<String, AppOption> map = new HashMap<String, AppOption>();

      String line = null;
      while((line = lineReader.nextNonEmptyLine()) != null) {
         // Get option name and value
         String[] values = parseLine(line);

         // Get AppOptionEnum
         AppOptionEnum optionEnum = enumMap.get(values[0]);
         if(optionEnum.getType().isList()) {
            //addValueToList(optionEnum, values[1]);
            addValueToList(values[0], values[1]);
            continue;
         }

         AppOption appOption = optionEnum.getType().parseValue(values[1]);
         if(map.put(values[0], appOption) != null) {
            LoggingUtils.getLogger().
                    warning("Duplicated key '"+values[0]+"' on line "+
                    lineReader.getLastLineIndex()+ " for non-list option.");
         }
      }

      // If table with lists is not empty, add those lists
      for(String key : lists.keySet()) {
         if(map.put(key, new AppOption(lists.get(key))) != null)  {
            LoggingUtils.getLogger().
                    warning("Found duplicated list '"+key+"' on table.");
         }
      }

      return map;
   }

  /**
   * 
   * @param line
   * @return String array with two elements; the first is the name of the option,
   * the second is the value.
   */
   private String[] parseLine(String line) {
      String[] values = new String[2];

      int spaceIndex = line.indexOf(ParsingConstants.SPACE);
      values[0] = line.substring(0, spaceIndex).trim();

      line = line.substring(spaceIndex+1);
      spaceIndex = line.indexOf(ParsingConstants.SPACE);

      // Ignore separator. Is only "decoration"
      values[1] = line.substring(spaceIndex+1).trim();

      return values;
   }

   /**
    * Adds a value to the table of lists.
    *
    * @param key
    * @param value
    */
   //private void addValueToList(AppOptionEnum key, String value) {
   private void addValueToList(String key, String value) {
      // Check if List already exists
      if(!lists.containsKey(key)) {
         lists.put(key, new ArrayList<String>());
      }

      lists.get(key).add(value);
   }

   private Map<String, List<String>> lists;
   //private Map<AppOptionEnum, List<String>> lists;






}
